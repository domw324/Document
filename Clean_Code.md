# Intro
##### 이 글은 개인 학습을 위해 책 내용을 기록하고, 관련된 정보들 및 생각을 기록합니다.  
## 책 소개
![책 표지](/images/CleanCode.Book_Cover.png)  
|  |
| :---: |
| **Clean Code(클린코드)<br>: 애자일 소프트웨어 장인 정신** |
| **Rovert C. Martin** |
|  박재호, 이혜영 옮김 |
| 인사이트 |

 위 책을 읽으면서 '좋은 코드'란 어떤 것이고, 어떤 습관을 가지면 좋을지 이 책에서 찾아보고자 한다.

# Clean Code Skill
## 01. Clean Code

## 02. 의미 있는 이름 - Naming

## 03. 함수 - Method
함수는 이해하기 쉽게, 예측할 수 있게, 유지관리하기 쉽게 작성해야한다. 어떻게 하면 함수를 잘 작성할 수 있을까?
##### 함수는 **짧을/작을** 수록 좋다.
##### 함수는 **한 가지 일**을 해야한다.
- 함수가 한 가지 일을 하는지 판단하는 방법으로는 함수 내 동작을 '**섹션**'으로 나눠보자. 하나의 일만 하는 함수는 여러 세션으로 나누기 어렵다.
##### 각 함수는 **하나의 추상화 수준**에서만 작동할 수 있도록 작성하자.
- ex: 한 함수내에서 Html, Server, 출력과 같은 여러 추상화 단계에서 동작하는 경우
- 코드를 읽는 사람이 헷갈리게 되고, 후에 다른 개발자들이 함수에 여러 세부사항을 더 추가하게 된다.
##### 코드는 **위에서 아래**로 읽히는 것이 좋다. 이야기 읽듯.
##### 함수명은 함수의 동작을 잘 표현할 수 있도록 서술적으로 풀어써도 좋다.
- 가능하면 입/출력까지 예측할 수 있으면 더 좋다.
- 함수명이 길어져도 괜찮다.
##### 함수의 **인수는 적을수록** 이해하기 쉽다.
- 인수가 많아질 수록 함수를 접하는 사람들은 더 많은 경우의 수를 조합해야 한다.
- 0개일 때가 가장 이상적!
- 인수가 필수적인 경우, 각 인수끼리 자연적인 순서가 있는 경우는 예외. // ex: x, y 좌표
- 인수를 묶어 하나의 객체로 넘겨주는 방법도 고려하자. // ex: 좌표 x, y → Point(x, y)
- 함수 이름에 인수 키워드를 추가하는 것도 시도해볼만하다.
##### 부수효과를 일으키지말자.
- 예측 된 함수의 동작 이외의 부수효과는 예상하지 못한 결과를 만든다.
- 예측할 수 없는 부수효과는 시간적 결합이나 순서 종속성을 빚는다.
##### 명령/조회 함수를 분리하자.
- ex: DB의 CRUD 함수 분리
##### 오류 코드(if)보다 **예외**(try-catch)를 사용하는 것이 좋다.
- 오류 코드를 쓰면 오류 발생 시 곧바로 오류를 처리해야하기 때문에 오류 처리코드와 원래 의도한 코드가 섞이게 된다.
- 예외를 사용하면, **원래 코드와 오류 처리코드가 명확히 분리**되어 코드가 깔끔해진다.
- try-catch문도 **throws Exception**을 사용해 별도 오류 처리 함수로 분리하면 더 깔끔해진다.
##### 코드 반복은 좋지 않다.
- 코드를 반복해서 짜게 되면 코드 길이가 늘어나고, 알고리즘이 변할 때 중복된 모든 곳을 수정해야 한다.
##### 큰 함수를 짤 때는 구조적 프로그래밍이 도움이 된다.
- 큰 함수 내에서 break나 continue등의 분기를 사용해 return 시기가 여러 곳이 되면 매우 복잡해진다. 그래서 단일 출/입구 규칙을 지키면 더 깔끔한 함수가 된다.
- 크기가 작은 함수에서는 크게 도움이 되지는 못한다.

## 04. 주석 - Comments
> 잘 달린 주석은 유용한 정보를 제공하고, 경솔하고 근거없는 주석은 코드를 이해하기 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨린다. - Clean Code 중  

일단, 주석은 오래될수록 코드에서 멀어지게 된다. 개발자들이 주석까지 유지보수하기는 현실적으로 불가능 하기 때문이다. 코드는 변화하고 진화하지만 주석은 이를 따라가지 못한다. 즉, 애초에 **주석이 필요없는 좋은 코드**를 짜는 것이 가장 좋은 방법이다.  
그럼에도 불구하고 주석이 필요하다면, 어떤 주석이 좋은 주석이고 나쁜 주석은 어떤 주석일까. 어떻게 달아야 할까?

##### 주석은 나쁜 코드를 보완하지 못한다
> 나쁜 코드에 주석을 달지 마라, 새로 짜라. - 브라이언 W. 커니핸, P.J. 플라우거
- 나쁜 코드를 보완하기 위해 주석을 달 시간에 코드를 개선하자.
##### 코드로 의도를 표현하자
- 주석으로 달려는 설명을 함수로 만들어 표현하는 것도 좋은 방법
##### 좋은 주석
- 법적인 주석
  - 회사가 정립한 구현 표준에 맞춰 법적인 이유로 넣은 특정 주석
  - ex: 저작권, 소유권
- 정보 제공 주석
  - ex: 추상 함수가 반환할 값 설명
  - 반환값을 클래스로 만들어 주석이 필요없게 할 수도 있다.
- 의도 설명 주석
  - 구조 설정 및 구현 방식 결정에 깔린 작성자의 의도를 설명
- 의미를 명효하게 밝히는 주석
  - 인수나 반환값이 표준 라이브러리이거나 변경하지 못하는 코드에 속하는 경우. (코드를 변경할 수 없으니 주석으로 의미를 명료하게 함)
- 결과를 경고하는 주석
- TODO
  - 필요하다고 여기지만 당장 구현이 불가능한 업무. 그 외의 알림, 요청, 부탁
  - 대다수 IDE에서 제공하는 TODO 주석 전부를 찾아 보여주는 기능을 함께 활용하면 더 좋다.
  - 그렇다고 TODO로 떡칠한 코드는 좋은 코드라고 할 수는 없다.
- 중요성 강조 주석
  - 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조
- 공개 API에서 Javadocs
  - 설명이 잘 된 API는 유용하고 만족스럽게 사용할 수 있다.
##### 나쁜 주석
- 거의 대부분의 주석
  - 허술한 코드 지탱, 엉성한 코드 변명, 미숙한 결정 합리화, ...
- 주절거리는 주석
  - 주석을 달기로 결정했다면 최고의 주석을 달도록 노력하자.
- 동일 내용 중복 주석
  - 코드 내용을 그대로 설명하는 주석
  - 자칫하면 코드보다 주석 읽는 시간이 더 오래걸린다. 심지어 읽는 사람이 함수를 대충 이해하고 넘어가게 만들 수도 있다.
- 오해할 여지가 있는 주석
- 의무적으로 다는 주석
  - 모든 함수/변수에 의무적으로 주석을 달 필요는 없다.
- 이력 기록 주석
  - 그냥 소스 코드 관리 시스템을 이용하자.
- 있으나 마나한 주석
  - 너무 당연한 사실. 쓰지 말자.
- 잡음
- 함수나 변수로 표현 가능한 주석
- 위치 표시 주석
- 닫는 괄호에 다는 주석
- 공로를 돌리거나 저자를 표시하는 주석
- 주석으로 처리한 코드
  - 과거 코드를 기억하고 싶다면, 소스 코드 관리 시스템을 사용하자.
- HTML 주석
- 전역 정보
  - 주석은 근처 코드만 기술해도 충분하다. 시스템의 전반적인 정보를 기술할 필요는 없다.
- 너무 많은 정보
  - 용건만 간단히
- 모호한 관계
  - 주석 자체가 새로운 설명이 필요해서는 안된다.
- 함수 헤더
  - 함수는 짧고 한 가지 기능만을 수행하고 이름을 잘 붙이면 그만이다.
- 비공개 코드의 Javadocs
  - 시스템 내부에 속해서 공개 되지 않는 코드라면, 주석으로 다른 이들에게 유용성을 제공할 수 없다.

## 05. 형식 맞추기
코드 형식은 코드를 짜는 규칙이고, 의사소통 방식이다. 이 의사소통은 전문 개발자의 일차적 의무이다.  
처음 짜놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. 코드는 변화해도 개발자의 스타일과 규율은 사라지지 않는다.  
물론 융통성 없이 맹목적으로 따르기만 해서는 안된다. 그렇다면 원활한 소통을 장려하는 코드 형식은 무엇일까?
##### 적절한 행 길이
일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.
- 신문 기사처럼 작성
  - 이름은 간단하면서 설명이 가능하게. 이름만 보고도 올바른 모듈을 살펴보고 있는지 판단 할 수 있도록 신경 써서 짓자.
  - 소스 파일 첫 부분은 고차원 개념과 알고리즘 설명
  - 아래로 내려갈수록 의도를 세세하게 묘사
  - 마지막에는 가장 저차원 함수와 세부 내역
- 개념은 빈 행으로 분리
  - 행 묶음은 완결된 생각 하나를 표현
  - 생각 사이에는 빈 행을 넣어 분리
  - 코드의 세로 레이아웃에 심오한 영향
- 세로 밀집도(수직 거리) = 연관성
  - 서로 연관성 있는 함수/변수들은 세로로 가깝게 둬야 한다.
  - 지역 변수 : 각 함수 맨 처음 / 루프 제어 변수 : 루프 문 내부 / 인스턴스 변수 : 클래스 맨 처음
  - 종속 함수 : 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치
  - 개념적 유사성 : 명명법이 똑같고 기본 기능이 유사한 요소들은 가까이 배치하는 것이 좋다.
- 세로 순서
  - 함수 호출 종속성은 아래 방향으로 유지(호출하는 함수 → 호출되는 함수 순). 고차원에서 저차원으로 자연스럽게 배치 된다.
##### 가로 형식
결론적으로는 짧은 행이 바람직하다. (요즘은 모니터 화면이 넓어져서 200자 까지도 출력되지만,, 120자 이하가 적당하다.)
- 가로 공백과 밀집도 = 개념의 밀접성
  - 공백을 넣으면 두 가지 주요 요소가 확실히 나뉘게 된다.
  - ex: int lineSize = line.length(); // 공백을 통해 할당 연산자와 피연산자를 분리, 공백을 넣지 않아 .length() 함수와 밀접성 강조
  - ex: return b\*b - 4\*a\*c; // 곱셈과 뺄셈의 우선순위 표시
- 가로 정렬
  - 선언문과 할당문의 지나친 줄세우기는 오히려 변수 유형을 무시하는 결과를 가져올 수 있다.
  - 꼭 필요하지 않다면 굳이 하지 않아도 괜찮다.
- 들여쓰기 = 범위, 계층 표시
  - 코드 읽는 과정은 들여쓰기에 매우 의존적임.
  - 들여쓰기를 통해 코드가 속하는 범위를 시각적으로 표현.
##### 팀 규칙
- 팀은 한 가지 규칙에 합의해야 하며, 모든 팀원은 그 규칙으 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 보인다.  
- 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다.  
- 스타일은 일관적이고 매끄러워야 한다.
- 한 소스에서 봤던 형식이 다른 소스 파일에도 쓰일 것이라는 신뢰감을 주자.

## 06. 객체와 자료구조
##### 자료 추상화
클래스 사용자가 변수에 의존하지 않게 하기 위해서는 추상화를 사용해 구현을 감추는 것이 좋다. 특히 **추상 인터페이스**를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있으면 더욱 좋다.
- 계층 관계를 이용하는 것, 인터페이스나 조회/설정 함수를 작성하는 것만으로는 구현을 감출 수는 없다.
- 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 고민해야 한다.
##### 자료/객체 비대칭
객체는 추상화 뒤로 자료를 숨기고 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하고 별다른 함수는 제공하지 않는다.  
이로인해 다음과 같은 특성이 발생한다.
> (자료구조를 사용하는) **절차적인 코드**는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.  
**객체 지향 코드**는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

> **절차적인 코드**는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다.  
**객체 지향 코드**는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

즉, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 따라서 시스템의 복잡성과 특성에 따라 적절히 활용해야한다. 서로 **비대칭적**이며, **상호보완적**이다.
- (복잡한 시스템은) 새로운 자료 타입이 필요한 경우가 많음 → 객체 지향 기법 유리
- 새로운 기능(함수) 확장이 자유로워야 하는 시스템 → 절차적인 코드 유리
##### 디미터/디메테르 법칙 (the Law of Demeter)
: 객체 지향 디자인 원칙 중 하나. 최소 지식 원칙(Principle of least knowledge)이다. 이 법칙은 모듈들 사이의 결합도를 줄여 코드 품질을 높이기 위해 제안되었다.  
이 법칙은 "클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다."고 제안한다.
> 클래스 C  
f가 생성한 객체  
f 인수로 넘어온 객체  
C 인스턴스 변수에 저장된 객체  

그리고 허용된 메서드가 반환하는 객체의 메서드는 다시 호출하면 안된다.
- 기차 충돌 (train wreck)
  - 객체의 메소드를 연달아 호출하는 경우
  ```cpp
    // train wreck
    final String outputDir = ctxt.getOptions().getScratchDir().getAbolutePath()

    // modified 1
    Options opts = ctxt.getOptions();
    File cratchDir = opts.getScratchDir();
    final String outputDir = scratchDir.getAbsolutePath();

    // modified 2
    final String outputDir = ctxt.options.scratchDir.absolutePath;
  ```
- 잡종 구조
  - 절반은 객체, 절반한 자료 구조인 구조. 
  - 새로운 함수 및 새로운 자료 구조를 추가하기 어렵다. 되도록이면 피하는 것이 좋다.
- 구조체 감추기
##### 자료 전달 객체 (Data Transfer Object, DTO)
: **공개 변수만 있고 함수가 없는 클래스**. 데이터베이스 통신, 소켓에서 받은 메시지 구문 분석 시 유용.
- 빈(bean)구조
  - 비공개 변수를 조회/설정 함수로 조작한다.
  ```java
    public class Address {
      private String street;
      // ...

      public  Address(String street/*, ..., ...*/) {
        this.street = street;
        // ...
      }
      
      public String getStreet() {
        return street;
      }
    }
  ```
- 활성 레코드
  - DTO의 특수한 형태.
  - 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조, 대개 save나 find 같은 탐색 함수도 제공
  - 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과
  - 활성 레코드 **자료구조**를 객체로 취급하는 경우 잡종 구조가 나올 수 있으니 주의할 필요가 있다.

## 07. 오류처리 
코드는 읽기도 좋아야 하지만 **안정성**도 높아야 한다. 그래서 오류 처리는 프로그램에 반드시 필요한 요소이다. 물론 오류 처리는 프로그램의 안정성 유지에 매우 중요하지만 오류 처리 코드 때문에 논리를 이해하기 어려워진다면 곤란하다.
##### 오류 코드보다 예외 사용
오류 플래그를 설정하거나 호출자에게 오류 코드를 반환하는 방법은 즉시 오류를 확인해야 하기 때문에 코드가 복잡해지고, 다음 단계로의 매끄러운 읽기를 방해한다. 하지만 예외를 사용해 오류를 처리하면 **실제 기능 구현 알고리즘과 오류 처리 알고리즘을 분리**할 수 있기 때문에 코드가 깔끔해진다.
```java
  // 1. 오류 코드 사용
  public void sendShutDown() {
    DeviceHandle handle = getHandle(DEV1); // 디바이스 상태 점검
    if (handle != DeviceHandle.INVALID) {
      retrieveDeviceRecord(handle); // 레코드 필드에 디바이스 상태 저장
      if (record.getStatus() != DEVICE_SUSPENDED) {
        // 디바이스가 정지상태가 아니면 종료
        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
      }
      else {
        logger.log("Device suspended. Unable to shut down");
      }
    }
    else {
      logger.log("Invalid handle for: " + DEV1.toString());
    }
    // ...
  }

  // 2. 예외 사용
  public void sendShutDown() {
    try {
      tryToShutDown();
    }
    catch (DeviceShutDownError e) {
      logger.log(e);
    }
  }

  private void tryToShutDown() throws DeviceShutDownError {
    DeviceHandle handle = getHandle(DEV1);
    DeviceRecord record = retrieveDeviceRecord(handle);

    pauseDevice(handle);
    clearDeviceWorkQueue(handle);
    closeDevice(handle);
  }

  private DeviceHandle getHandle(DeviceID id) {
    // ...
    throw new DeviceShutDownError("Invalid handle for: " + id.toString());
    // ...
  }
```
##### Try-Catch-Finally
- 예외가 발생하는 코드를 try-catch-finally문으로 시작하면 프로그램 안에 일종의 범위를 지정 할 수 있다.
- 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 것도 방법이다.
##### 미확인(unchecked) 예외 사용
- 확인된 예외는 OCP(Open Closed Principle)를 위반한다.
- 대규모 시스템의 말단 함수에서 새로운 예외를 던지는 경우, 선언부에 throws 절을 추가해야하고 이 함수를 호출하는 함수들은 catch 블록에서 새로운 예외를 처리하거나 선언부에 throw 절을 추가해줘야 한다. 따라서 확인된 예외가 캡슐화를 깨버리게 된다.
##### 예외에 의미 제공
- 예외를 던질 때문 전후 상황이 충분히 설명되어야 한다.
- 오류 메시지에 정보를 담아 예외와 함께 던지는 방법이 좋다. (ex: 실패한 연산이름, 실패 유형)
##### 호출자 고려한 예외 클래스 정의
- 예외 유형과는 무관하게 호출하는 라이브러리 API를 예외를 처리하는 클래스로 감싸서(**wrapper Class**) 예외 유형 하나를 반환하게 하면 좋다.
```java
// LocalPort: ACMEPort 클래스가 던지는 예외를 잡아 변환하는 wrapper Class
LocalPort port = new LocalPort(12);
try {
  port.open();
}
catch (ProtDeviceFailure e) {
  reportError(e);
  logger.log(e.getMessage(), e);
}
finally {
  // ...
}
```
- 위 방법은 외부 API를 사용할 때 예외를 처리할 수 있는 최선의 방법이다.
- 위 방법으로 외부 라이브러리와 프로그램 사이의 의존성을 크게 줄일 수 있다. 또한 다른 라이브러리로 갈아탈 때도 적은 비용이 든다.
- wrapper Class에서 외부 API를 호출하는 대신 테스트 코드를 넣어주면 프로그램 테스트도 쉬워진다.
##### 정상 흐름 정의
- (특수 사례 패턴의 경우) 클래스를 만들거나 객체를 조작해 처리하면 좋다. 그러면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다.
##### null 반환/전달 지양
- null은 다른 사람(호출자)에게 문제의 책임을 떠넘기는 것이다!
- null 자체를 정상적인 인수로 기대하는 경우가 아니라면 null은 전달하지 않는 것이 옳다.
- **빈 리스트**를 반환하거나, **assert()**를 사용해 null이 전달되지 않게 null을 처리할 수 있다.

## 08. 경계
시스템의 모든 소프트웨어를 직접 개발하는 경우는 드물다. 패키지 혹 은 오픈 소스 등 각종 코드들을 통합해야할 필요성이 있다. 이때 각 소프트웨어 경계를 깔끔하게 처리하는 기술이 필요하다.
##### 외부 코드
패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려하고, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이 경계에서 문제가 생긴다.
- 외부 코드가 필요 이상의 기능을 제공하는 경우, 클래스로 한번 더 캡슐화를 하는 것도 좋은 방법이다.
- 이는 그 인터페이스 자체를 여기저기 넘겨주지 말라는 의미.
##### 학습 테스트
- 외부 코드를 익히는 것, 통합하는 것 모두 어렵다.
- 먼저 간단한 테스트 케이스를 작성한 후 외부 코드를 익히는 **학습 테스트**를 진행하는 것을 추천. API 이해도를 높여주는 정확한 방법.
- 물론 학습 테스트 검증 이후에 패키지가 실제 코드와 호환된다는 보장은 없지만, 새 버전이 코드와 호환되지 않으면 핛브 테스트가 이 사실을 곧바로 알려준다.
##### 깨끗한 경계
- 경계에 위치하는 코드는 깔끔히 분리
- 기대치를 정의하는 테스트 케이스 작성
- 외부 패키지를 호출한느 코드는 가능한 줄여 경계 관리.
- 새로운 클래스로 경계를 감싸거나 ADAPTER 패턴을 사용해 코드를 패키지가 제공하는 인터페이스에 맞춰 변환. 코드 가독성, 일관성, 유지관리 용이성이 좋아진다.

## 09. 단위 테스트
##### TDD 세가지 법칙
> TDD(Test Driven Development, 테스트 주도 개발) : 테스트가 개발을 이끌어 나가는 형태의 개발론
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.  
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.  
3. 현재 실패하는 테스트를 통화할 정도로만 실제 코드를 작성한다.  
##### 깨끗한 테스트코드의 필요성
- 테스트는 코드에게 **유연성, 유지보수성, 재사용성** 제공한다.
- 코드가 변하면 테스트 코드도 변해야 한다. 
- 테스트 코드가 지저분할 수록 코드 변경이 어렵다.  
테스트 코드가 복잡할 수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 쉽기 때문이다.
- 결국 **테스트코드는 실제 코드 못지 않게 중요하다.**
##### 깨끗한 테스트코드
테스트 코드에서 **가독성**은 정말 중요하다. 그리고 가독성을 높이기 위해서는 **명료성, 단순성, 풍부한 표현력**이 필요하다. 또한 **최소 표현으로 최대한 많은 것**을 나타내야 한다.
- 도메인에 특화된 테스트 언어
  - 실제 코드의 함수를 그대로 가져다 쓰는 것보다. 테스트를 위해 함수와 유틸리티를 직접 구현해 사용하면 좀 더 간결하고 표현력이 풍부하게 작성할 수 있다.
- 이중 표현
  - 주로 메모리나 CPU 효율을 위해 활용한다.
  - 사실 이중 표현은 코드의 깨끗함과는 무관하다.
##### Test 당 Assert 하나
- 하나의 테스트에는 최대한 적은 Assert가 있으면 좋다.
- 테스트 당 개념 하나
##### F.I.R.S.T.
- Fast : 빠르게. 테스트는 빨라야한다. 자주 돌릴 수 있어야 한다.
- Independent : 독립적으로. 각 테스트는 서로 의존하면 안 된다. 연쇄적 실패로 이어져 결함이 감춰진다.
- Repeatable : 반복가능하게. 어떤 환경에서도 반복 가능해야한다.
- Self-Validating : 자가검증하는. 테스트는 bool 값으로 결과를 내야한다. 즉, **성공** 아니면 **실패**이다.
- Timely : 적시에. 테스트는 적절한 때에 작성해야한다. 단위 테스트는 테스트하련는 실제 코드 구현 직전에 구현하는 것이 가장 좋다.

## 10. 클래스
##### 클래스 체계
자바에서의 클래스 정의 표준 관례에서는 static 상수, public 상수, static private 변수, private 변수 순으로 작성된다. public 변수가 필요한 경우는 거의 없다. 변수 목록 다음에는 public 함수가 나오고 private 함수는 자신을 호출하는 public 함수 직후에 넣는다.  
즉, 추상화 단계가 순차적으로 내려간다.
- 캡슐화
  - 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫다.
  - 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 public으로 선언한다.
  - 최대한 비공개 상태를 유지하고, 캡슐화를 풀어주는 것은 최후.
##### 클래스는 작게
- 클래스의 크기 척도 : **클래스가 맡은 책임**의 크기
  - 클래스에 대한 설명(혹은 클래스 이름)이 간결할 수 있을 정도로 클래스에게 적은 책임을 부여해야한다.
  - 클래스 이름이 모호하다면 너무 많은 역할을 하고 있지는 않을까 생각해보자.
- **단일 책임 원칙 (Single Responsibility Principle. SRP)**
  - 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙. 객체지향에서 매우 중요.
  - 클래스를 변경해야하는 이유를 파악하려 애쓰면 더 좋은 추상화가 더 쉽게 떠오를 수 있다.
- 응집도 (Cohesion)
  - 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인 정도
  - 각각의 모든 함수가 모든 인스턴스 변수를 사용할수록 함수와 클래스는 응집도가 높다.
  - 클래스의 **인스턴스 변수 수는 적게, 매개변수 목록은 짧게** 한다.
- 응집도를 유지하면 작은 클래스 여러개가 나온다.
  - 함수를 쪼개는 과정에서 매개변수 개수를 줄이려면 클래스의 인스턴스 변수로 승격시키면 된다. 하지만 이 방법은 클래스의 응집도를 잃는다. 이 때 응집도를 유지하고 싶다면 **클래스를 분리**시키면 된다.
##### 클래스는 변경하기 쉽게
대다수 시스템은 지속적으로 변경된다. 그리고 변경 시 의도대로 동작하지 않을 위험이 따른다.
- **SRP**와 **OCP**를 지키자.
- **OCP (Open-Closed Principle)** : 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원칙.
- 변경으로부터 격리
  - "시스템(클래스 간)의 결합도가 낮다"는 시스템 요소로부터, 변경으로부터 잘 격리되어 있다는 의미. 또한 각 요소를 이해하기 쉬워진다.
  - 결합도를 줄이다보면 DIP 클래스 설계 원칙을 지키는 클래스가 자연스럽게 나온다.
  - **DIP(Dependency Inversion Principle)** : 클래스는 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙.
  - 결합도를 낮추기 위해서 상속관계를 활용해 클래스의 역할을 적절히 분리 및 격리시킬 수 있다.

## 11. 시스템
시스템에서는 추상화와 모듈화가 매우 중요한 요소이다. 또한 시스템 수준에서도 깨끗한 코드를 유지하는 것 중요하다.  
깨끗하지 못한 아키텍처는 도메인 논리를 흐리고 기민성을 떨어뜨린다. 도메인 논리가 흐려지면 제품 품질이 떨어진다.  
모든 추상화 단계에서 의도는 명확히 표현해야한다.
##### 시스템 제작과 시스템 사용을 분리
소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는)준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.
- 초기화 지연, 계산 지연 기법은 단일 책임 원칙을 깰 여지가 있다.
- Main 분리
  - 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮긴다.
- 팩토리
  - 객체가 생성되는 시점을 애플리케이션이 결정하는 방식.
- 의존성 주입 (Dependency Injection)
  - 사용과 제작을 분리하는 강력한 메커니즘 (제어 역전 기법을 의존성 관리에 적용한 형태)
  - 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 대개 '책임질'메커니즘으로 'main' 루틴이나 특수 **컨테이너**를 사용한다.
##### 확장
처음부터 확장 가능성을 완벽하게 파악하고 시스템을 설계하기는 불가능에 가깝다. **대신 테스트 주도개발(TDD), 리팩토링, 깨끗한 코드**는 시스템을 조정하고 확장하기 쉽게 만든다.
- 모든 객체가 전반적으로 동일한 방식을 이용하게 만든다. (ex. 테이블과 열의 명명 관례, 일관적인 트랙잭션 의미)
- 횡단(cross-cutting) 관심사
  - 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다. 하지만 현실적으로는 온갖 객체로 흩어지게된다. 이것이 **횡단 관심사**이다.
- **관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)**
  - 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론
  - 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다. 라는 모듈 구성 개념
##### 자바 프록시
##### 순수 자바 AOP 프레임워크
##### AspectJ 관점
##### 테스트 주도 시스템 아키텍처 구축
- 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능하다. 또한 새로운 기술을 채택해 단순한 아키텍처를 복잡한 아키텍처로 키워갈 수도 있다.
- BDUF(Big Design Up Front. 구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 방식)를 할 필요도 없어진다.
- 프로젝트 시작 시 **일반적 범위, 목표, 일정, 시스템의 일반적 구조**를 생각해야하며, 환경 변화에 대처해 진로를 변경할 능력도 반드시 유지해야 한다.
##### 의사 결정 최적화
가장 적합한 사람에게 책임을 맡겨 충분한 고민을 통해 결정할 수 있도록 한다.
##### 명백한 가치가 있을 때 표준을 현명하게 사용
- 표준의 장점 : 아이디어와 컴포넌트 재사용 쉬움, 적절한 경험자 구하기 쉬움, 좋은 아이디어 캡슐화 쉬움, 컴포넌트 구조화 쉬움
- 표준의 단점 : 표준 제정 시간 오래걸림
##### 도메인 특화 언어
도메인에 대해 정보를 명료하고 정확하게 전달할 수 있는 어휘, 관용구, 패턴이 필요하다.
- DSL(Domain-Specific Language)
  - 간단한 스크립트 언어나 표준 언어로 구현한 API
  - 좋은 DSL은 도메인 개념과 구현 코드 사이의 '의사소통 간극'을 줄여준다. 또한 도메인 논리 구현 시 도메인을 잘못 구현할 가능성이 줄어든다.
  - 효과적인 DSL 사용은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다.

## 12. 창발성
> 창발성 : 남이 모르거나 하지 아니한 것을 처음으로 또는 새롭게 밝혀내거나 이루어 내는 성질 (출처 : NAVER 국어사전)
##### 창발적 설계로 깔끔한 코드 구현
단순 설계 규칙 네 가지를 활용하면 소프트웨어 설계 품질을 크게 높여준다고 제안한다.
1. 모든 테스트 실행
2. 중복 제거
3. 프로그래머 의도 표현
4. 클래스와 메서드 수 최소화

또한 코드 구조와 설계를 파악하기 쉬워지며 SRP나 DIP 원칙을 적용하기 쉬워진다고 말한다.  
(SRP : Single Responsibility, 단일 책임 원칙)
(DIP : Dependency Incersion Principle, 의존 관계 역전 원칙)
##### 단순 설계 규칙 1 : 모든 테스트를 실행
테스트 케이스를 만들고 계속 돌리는 규칙을 따르면 시스템은 **낮은 결합도**와 **높은 응집력**을 가지게 된다.
- 검증이 불가능한 시스템은 절대 출시하면 안된다.
- 테스트가 가능한 시스템을 만드려고 애쓰면 설계 품질이 함께 높아진다.
- 테스트 케이스가 많을수록 개발자는 테스트가 쉽게 코드를 작성한다.
##### 단순 설계 규칙 2~4 : 리팩토링
코드를 점직적으로 리팩토링 한다. 이때 이미 테스트 케이스가 잘 짜져있다면 코드를 정리하면서 시스템이 깨지지 않는다. (깨지려고 하면 알려주니까!)
- 응집도 높이고, 결합도를 낮추고, 관심사 분리, 모듈화, 함수와 클래스 크기 축소, 더 좋은 네이밍, 중복 제거, 프로그래머 의도 표현, 클래스와 메소드 수 최소화
##### 중복 제거
- 중복은 불필요한 추가 작업, 추가 위험, 불필요 복잡도를 가져온다.
- Template Method 패턴은 고차원 중복을 제거할 목적으로 자주 사용되는 기법이다.
##### 표현
코드를 읽을 사람을 배려하면서 개발하자. 개발 의도를 적절히 표현한다면 유지보수 기용을 절감할 수 있다.
- 좋은 이름 선택
- 함수와 클래스 크기 줄이기
- 표준 명칭 사용
- 단위 테스트 케이스 꼼꼼이 작성
##### 최소 클래스 & 최소 메소드
무의미하게 분리된 클래스 중복을 제거하자.
- 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 것이 목표
